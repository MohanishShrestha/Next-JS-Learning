#Routing conventions 
1) All routes must live inside the app folder
2) Route files must be named either page.js or page.tsx
3) Each folder represents a segments of the URL path

when convetion are followed the file automatically becomes available as a routes

#folder name -> page.tsx   
ie profile-> page.tsx    
we can access it by http://localhost:3000/profile



#Nested routes
localhost:3000/profile
localhost:3000/profile/user1
folder name(profile) -> page.tsx  + folder1 + folder2 
folder1 (first)-> page.tsx
folder2 (second)-> page.tsx
ie profile-> page.tsx    
we can access it by http://localhost:3000/profile/first  => access first folder



#dynamic routes
folder name(profile) -> page.tsx  + [folder1] 
[folder1] -> page.tsx
localhost:3000/profile/1 


#nested dynamic routes
localhost:3000/product/1/review/1


#catch all segments 
here by using [...slug]-> page.tsx we can accept all URL
do[[...slug]] so that default can also be called
using this we can call multiple url 


#Not Found page
file name must be exactly not-Found in app
we can import the not-found ie import { notFound } from "next/navigation";and add notfound file here on folder and edit as we like
if we need to show different msg usePathname
to use we need to use client ie "use client" look at review not-found


#file colocation
we can saftly colocate file route segments in app directory without worrying them becoming Routing
we can also use external folder so it doesn't make routing



#private folder
- for internal stuff and Next js knows
- the folder and all its subfolders are excliided from Routing
- add an underscore at the start of the folder name ie _lib

useful for
- keeping your UI logic separate from routing logic
- Having a consistent way to organize internal files in your project
- Making it easier to group related files in your code editor
- Avoiding potential naming conflicts with future Next.js file naming conventions

if u want to actually want an underscore in your URL, use "%5F" instead, That's just
the URL-encoded version of an underscore

#Route groups
let us logically organize our routes and project files without impacting the URL structure
 ie register, login, forgetPassword in (auth)


#layout
like header content footer
to create a layout export a react component from a layout.js or layout.tsx file
that component takes a children prop which Next.js will populate with your page content
header ra footer lai root ma rakhna layout.tsx ma garra jun page gaye ni hatdaina ani


#Nested layout
we can also add on different folder like on review folder


# Multiple root layouts
route group uses 
- organize our project structure without affecting URLs
- Apply layout selectively to specific parts of our app
see tutorial2 for example 
here we have put main layout file on each route group so that each have its own layout
also add atleast root or main page.tsx on the route group


# Routing meta data 
the metadata api in next js is a prowerful feature that lets us define metadata for each page 
metadata ensures our content looks great when its shared or indexed by search engines
two ways to handle metadata in layout.tsx or page.tsx file:
- export a static metadata object
- export a dynamic generateMetadata function

Configuring metadata
Metadata rules
- Both layout.tsx and page.tsx can export metadata. layout metadata
  applies to all its pages, while page metadata is specific to that page
- Metadata follows a top-down order, starting the root level
- When metadata exists in multiple places along a route, they merge together,
  with page metadata overridding layout metadata for matching properties

look using inspect where title and meta data is shown
 note: deeper metadata take priority

 
#title metadata
- default(automatical use it if no title is there), 
  template (to add prefixes ie %s | codeevolution if i access blog then title will be blog(title) | codeevolution), 
  absolute (if u want only the title you give then this)

 # navigation
 File based routing syatem
 Defining routes for our applications root, nested routes, dynamic routes, and catch-all routes
 we have been typing Urls directly in the browser to test these routes
 Users
 - click links 
 - get redirected after certain actions

 UI navigation
 for client side navigaton we use <Link> component
 ie <Link href="/products/2">Product 2</Link>

 if we use replace <Link href="/products/3" replace>Product 3</Link>
and we go back it goes to not previous page but goes to home page
replace overwrite current history


#Active links
Making or showing the link u are in is active 
 const isActive = pathname === link.path || (pathname.startsWith(link.path) && link.path !== "/");
                return (
                    <Link className={isActive? "text-blue-500 font-bold mr-4" : "text-blue-500 mr-4"} key={link.name} href={link.path}>
                        {link.name}
                    </Link>
                )


#params and searchParams
for a given URL,
- params is a promise that resolves to an object containing the dynamic
  route parameters (like id)
- searchParams is a promise that resolves to an object containing
  the query parameters (lke filters and sorting)
Note -> while page.tsx has access to both params and searchParams , layout.tsx only has access to params


#Navigating Programmatically
after doing certain action a certain action get executed
 const handleClick = () => {
    console.log("Order placed successfully!");
    router.push("/");
  };


# template
-templates are similar to layouts in that they are also UI shared between multiple
 pages in your app
- Whenever a user navigates between routes sharing a template yo get a 
 complete fresh start
  * a new template component instance is mounted
  * DOM elements are recreated
  * state is cleared
  * effects are re-synchronized

create by 
- exporting a default react component from a template.js or tsx file
- like layouts templates need to accept a children prop to render the nested oute segments

simply make layout to template.tsx
we can also use both layout and template together
layout render first and its children are placed by templates
mostly layout is used 


#loding UI
loading.tsx
this file helps us create loading states that users see while waiting for content to load in a specific route segments
the loading state appear instantly when navigating letting users know that the application is responsive and actively loading content

benefit
user gets immidate feedback
makes app feel responsive and users know they did something
make layout reactive

# Error handling
error boundry must be client component
create a error.tsx or js
- it automatically wraps route segments and their nested childern in a  react Error boundey
- you can create error UIs for specific segments using the file-system hierarchy
- it isolates error to affected segments while keeping the rest of your app functional
- it enables you to attempt to recover from an error without requiring a full page reload

# recovering from errors

# handling errors in nested routes
- errors always bubble up to find the closest parent error boundary
- an error.tsx file handles errors not just for its own folder but for all the nested child segments below it too
-  by strategically placing error.tsx files at differnt levels in your route folders you can control exactly how detailed your error handling gets
i.e moving error from review to product folder
- where you put your error.tsx file makea huge difference 
it determines exactly which parts of your UI get affected when things go wrong

# handling errors in layouts
error.tsx file wont handle error of layout from same segments
move the file to outer folder


#handling global errors
make error-wrapper.tsx and global-error.tsx  
here the error-wrapper helps to smiluate the error 
but global-error will not appear on developer  and works only on producyion mode (npm build and npm run start)

- if an error boundary can't catch errors in layout.tsx file from the same segment what about errors in the root layout?
- it doesn't have a parent segment - how do we handle those error?
Next.js provides a special file called global-error.tsx that goes in your root app directort
-this is ur last line of defence when somethings goes catastrophically wrong at the highest level of ur app
    - works only in production mode
    - requires html and body tags to be rendered

# Parallel routes
what are they 
- complex dashboard can be done tradiationlly way like making component and adding them on organize
- Parallel routes in next.js are defined using a feature known as "slots"
- SLots help organize content in a modular way
- to create a slot we use the `@folder` naming conventions
- Each defined slot automatically becomes a prop in it corresponnding `layout.tsx` file

Parallel routes use cases
- Dashboards with multiple sections
- Split-view interfaces
- Multi-pane layouts
- Complex admin interfaces

Benefits
1) Parallel routes are great for splitting a layout into manageable slots
(espicially when different team work on different parts)
2) Independent route handling (each loading and error handling)
  - Each slott in your layout , such as users, revenue and notifications, 
  can handle its own loading and error states
  - This granular control is particularly useful in scenarios where different sections of the page 
  load at varying speeds or encounter unique errors
3) Sub-navigation
  - each slot can essentially function as a mini application complete with its own 
  navigation and state management
  - User can interact with each section separately, applying filters, sorting data or navigation
  through pages without affecting other parts


 # Unmatched routes
 Navigation from the UI
 - when navigating the UI(like clicking links), Next.js keeps showing
 whatever was in the Unmatched slots before

 Page reload
 - Next.js looks for a `default.tsx` file in each unmatched slot
 - This file is critical as it serves as a fallback to render content when the framework
 con't retrive a slots active state from the current URL
 - Without the file you will get a 404 error
 

 #conditional routes
 -imagine u want to show different content  based on whether a user
  is logged in or not
- u might want to display a dashboard for authenticed users but show a login
  page for those who are not
- Conditional routes allow us to achieve this while mantining completly separate code on the
  same URL


  #Intercepting routes
  -It is an advance routing mechanism that allows you to load a route from part of your application within
   the current layout
  - Its particularly useful when u want to display new content
    while keeping your user in the same context

  conventions:
  1) use (.) to match segments on the same level
  2) use (..) to match segments one level above
  3) use (..)(..) to match segments 2 level above
  4) use (...) to match segments from the root app directory

 
