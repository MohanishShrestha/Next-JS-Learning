#Routing conventions 
1) All routes must live inside the app folder
2) Route files must be named either page.js or page.tsx
3) Each folder represents a segments of the URL path

when convetion are followed the file automatically becomes available as a routes

#folder name -> page.tsx   
ie profile-> page.tsx    
we can access it by http://localhost:3000/profile



#Nested routes
localhost:3000/profile
localhost:3000/profile/user1
folder name(profile) -> page.tsx  + folder1 + folder2 
folder1 (first)-> page.tsx
folder2 (second)-> page.tsx
ie profile-> page.tsx    
we can access it by http://localhost:3000/profile/first  => access first folder



#dynamic routes
folder name(profile) -> page.tsx  + [folder1] 
[folder1] -> page.tsx
localhost:3000/profile/1 


#nested dynamic routes
localhost:3000/product/1/review/1


#catch all segments 
here by using [...slug]-> page.tsx we can accept all URL
do[[...slug]] so that default can also be called
using this we can call multiple url 


#Not Found page
file name must be exactly not-Found in app
we can import the not-found ie import { notFound } from "next/navigation";and add notfound file here on folder and edit as we like
if we need to show different msg usePathname
to use we need to use client ie "use client" look at review not-found


#file colocation
we can saftly colocate file route segments in app directory without worrying them becoming Routing
we can also use external folder so it doesn't make routing



#private folder
- for internal stuff and Next js knows
- the folder and all its subfolders are excliided from Routing
- add an underscore at the start of the folder name ie _lib

useful for
- keeping your UI logic separate from routing logic
- Having a consistent way to organize internal files in your project
- Making it easier to group related files in your code editor
- Avoiding potential naming conflicts with future Next.js file naming conventions

if u want to actually want an underscore in your URL, use "%5F" instead, That's just
the URL-encoded version of an underscore

#Route groups
let us logically organize our routes and project files without impacting the URL structure
 ie register, login, forgetPassword in (auth)


#layout
like header content footer
to create a layout export a react component from a layout.js or layout.tsx file
that component takes a children prop which Next.js will populate with your page content
header ra footer lai root ma rakhna layout.tsx ma garra jun page gaye ni hatdaina ani


#Nested layout
we can also add on different folder like on review folder


# Multiple root layouts
route group uses 
- organize our project structure without affecting URLs
- Apply layout selectively to specific parts of our app
see tutorial2 for example 
here we have put main layout file on each route group so that each have its own layout
also add atleast root or main page.tsx on the route group


# Routing meta data 
the metadata api in next js is a prowerful feature that lets us define metadata for each page 
metadata ensures our content looks great when its shared or indexed by search engines
two ways to handle metadata in layout.tsx or page.tsx file:
- export a static metadata object
- export a dynamic generateMetadata function

Configuring metadata
Metadata rules
- Both layout.tsx and page.tsx can export metadata. layout metadata
  applies to all its pages, while page metadata is specific to that page
- Metadata follows a top-down order, starting the root level
- When metadata exists in multiple places along a route, they merge together,
  with page metadata overridding layout metadata for matching properties

look using inspect where title and meta data is shown
 note: deeper metadata take priority

 
#title metadata
- default(automatical use it if no title is there), 
  template (to add prefixes ie %s | codeevolution if i access blog then title will be blog(title) | codeevolution), 
  absolute (if u want only the title you give then this)

 # navigation
 File based routing syatem
 Defining routes for our applications root, nested routes, dynamic routes, and catch-all routes
 we have been typing Urls directly in the browser to test these routes
 Users
 - click links 
 - get redirected after certain actions

 UI navigation
 for client side navigaton we use <Link> component
 ie <Link href="/products/2">Product 2</Link>

 if we use replace <Link href="/products/3" replace>Product 3</Link>
and we go back it goes to not previous page but goes to home page
replace overwrite current history


#Active links
Making or showing the link u are in is active 
 const isActive = pathname === link.path || (pathname.startsWith(link.path) && link.path !== "/");
                return (
                    <Link className={isActive? "text-blue-500 font-bold mr-4" : "text-blue-500 mr-4"} key={link.name} href={link.path}>
                        {link.name}
                    </Link>
                )


#params and searchParams
for a given URL,
- params is a promise that resolves to an object containing the dynamic
  route parameters (like id)
- searchParams is a promise that resolves to an object containing
  the query parameters (lke filters and sorting)
Note -> while page.tsx has access to both params and searchParams , layout.tsx only has access to params


#Navigating Programmatically
after doing certain action a certain action get executed
 const handleClick = () => {
    console.log("Order placed successfully!");
    router.push("/");
  };


# template
-templates are similar to layouts in that they are also UI shared between multiple
 pages in your app
- Whenever a user navigates between routes sharing a template yo get a 
 complete fresh start
  * a new template component instance is mounted
  * DOM elements are recreated
  * state is cleared
  * effects are re-synchronized

create by 
- exporting a default react component from a template.js or tsx file
- like layouts templates need to accept a children prop to render the nested oute segments

simply make layout to template.tsx
we can also use both layout and template together
layout render first and its children are placed by templates
mostly layout is used 


#loding UI
loading.tsx
this file helps us create loading states that users see while waiting for content to load in a specific route segments
the loading state appear instantly when navigating letting users know that the application is responsive and actively loading content

benefit
user gets immidate feedback
makes app feel responsive and users know they did something
make layout reactive

# Error handling
error boundry must be client component
create a error.tsx or js
- it automatically wraps route segments and their nested childern in a  react Error boundey
- you can create error UIs for specific segments using the file-system hierarchy
- it isolates error to affected segments while keeping the rest of your app functional
- it enables you to attempt to recover from an error without requiring a full page reload

